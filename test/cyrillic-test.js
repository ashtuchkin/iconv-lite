"use strict";

var assert = require("assert"),
    utils = require("./utils"),
    iconv = utils.requireIconv();

var baseStrings = {
    empty: "",
    hi: "Привет!",
    ascii: '\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f'+
           ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\x7f',
    rus: "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
    additional1: "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬\xAD®Ї°±Ііґµ¶·ё№є»јЅѕї",
    additional2: "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©",
    additional3: " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏ№ёђѓєѕіїјљњћќ§ўџ",
    untranslatable: "£Åçþÿ¿",
};

var encodings = [
    {
        name: "Win-1251",
        variations: ['win1251', 'Windows-1251', 'windows1251', 'CP1251', 1251],
        encodedStrings: {
            empty: utils.bytesFrom([]),
            hi: utils.bytesFrom([0xcf,0xf0,0xe8,0xe2,0xe5,0xf2,0x21]),
            ascii: utils.bytesFrom(baseStrings.ascii.split('').map(c => c.charCodeAt(0))),
            rus: utils.bytesFrom([0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff]),
            additional1: utils.bytesFrom([0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf]),
        }
    },
    {
        name: "Koi8-R",
        variations: ['koi8r', 'KOI8-R', 'cp20866', 20866],
        encodedStrings: {
            empty: utils.bytesFrom([]),
            hi: utils.bytesFrom([0xf0,0xd2,0xc9,0xd7,0xc5,0xd4,0x21]),
            ascii: utils.bytesFrom(baseStrings.ascii.split('').map(c => c.charCodeAt(0))),
            rus: utils.bytesFrom([0xe1,0xe2,0xf7,0xe7,0xe4,0xe5,0xf6,0xfa,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,0xf0,0xf2,0xf3,0xf4,0xf5,0xe6,0xe8,0xe3,0xfe,0xfb,0xfd,0xff,0xf9,0xf8,0xfc,0xe0,0xf1,0xc1,0xc2,0xd7,0xc7,0xc4,0xc5,0xd6,0xda,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd2,0xd3,0xd4,0xd5,0xc6,0xc8,0xc3,0xde,0xdb,0xdd,0xdf,0xd9,0xd8,0xdc,0xc0,0xd1]),
            additional2: utils.bytesFrom([0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf]),
        }
    },
    {
        name: "ISO 8859-5",
        variations: ['iso88595', 'ISO-8859-5', 'ISO 8859-5', 'cp28595', 28595],
        encodedStrings: {
            empty: utils.bytesFrom([]),
            hi: utils.bytesFrom([0xbf,0xe0,0xd8,0xd2,0xd5,0xe2,0x21]),
            ascii: utils.bytesFrom(baseStrings.ascii.split('').map(c => c.charCodeAt(0))),
            rus: utils.bytesFrom([0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef]),
            additional3: utils.bytesFrom([0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff]),
        }
    }
];

describe("Test Cyrillic encodings #node-web", function() {
    encodings.forEach(function(encoding) {
        var enc = encoding.variations[0];
        var key = "hi";
        describe(encoding.name+":", function() {

            it("Convert from buffer", function() {
                for (const key in encoding.encodedStrings)
                    assert.strictEqual(
                        iconv.decode(encoding.encodedStrings[key], enc),
                        baseStrings[key]
                    );
            });

            it("Convert to buffer", function() {
                for (const key in encoding.encodedStrings)
                    assert.strictEqual(
                        utils.hex(iconv.encode(baseStrings[key], enc)),
                        utils.hex(encoding.encodedStrings[key])
                    );
            });

            it("Try different variations of encoding", function() {
                encoding.variations.forEach(function(enc) {
                    assert.strictEqual(
                        iconv.decode(encoding.encodedStrings[key], enc),
                        baseStrings[key]
                    );
                    assert.strictEqual(
                        utils.hex(iconv.encode(baseStrings[key], enc)),
                        utils.hex(encoding.encodedStrings[key])
                    );
                });
            });

            it("Untranslatable chars are converted to defaultCharSingleByte", function() {
                const untranslatableBytes = utils.bytesFrom(
                    baseStrings.untranslatable.split('').map(() => iconv.defaultCharSingleByte.charCodeAt(0))
                );
                assert.strictEqual(
                    utils.hex(iconv.encode(baseStrings.untranslatable, enc)),
                    utils.hex(untranslatableBytes)
                ); // Only '?' characters.
            });
        });
    });
});

